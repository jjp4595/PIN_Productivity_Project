# -*- coding: utf-8 -*-
"""
Network analysis
"""
import pickle
import networkx as nx
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
import seaborn as sns
import matplotlib.gridspec as gridspec
from mpl_toolkits.axes_grid1 import make_axes_locatable
import os
import pandas as pd


def save_obj(obj, name ):
    with open('obj/'+ name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)
#save_obj(lsoa_dist, "lsoa_data")
def load_obj(name ):
    with open('obj/' + name + '.pkl', 'rb') as f:
        return pickle.load(f)


#------------------------------------------------------------------------------
#
#                   Analysis Sections...
#
#------------------------------------------------------------------------------


def density_ratio(first, second):#amended so it doesn't use a list comprehension and does an all-to-all operation
    first = first[:,np.newaxis]
    ratios = first/second
    ratios = ratios.flatten()
    sorted_ratios = np.sort(ratios)
    median_50 = sorted_ratios[int((len(ratios) * 0.5))]
    ratio_25 = sorted_ratios[int((len(ratios) * 0.25))]
    ratio_75 = sorted_ratios[int((len(ratios) * 0.75))]
    mean, sigma = np.mean(ratios), np.std(ratios)
    conf_int = stats.norm.interval(0.95, loc=mean, scale=sigma / np.sqrt(len(ratios)))
    #fig, ax = plt.subplots(1,1)
    #ax.hist(ratios, bins = 20 , density=True)
    info = {
        "sorted_ratios":sorted_ratios,
        "median": median_50,
        "25th":ratio_25, 
        "75th":ratio_75,
        "mean":mean,
        "sigma":sigma, 
        "conf_int":conf_int
        }
    
    return info

# #-----------------------------------------------------------------------------



def layoutgraphs():
    from synthetic_network import paths_shuffle
    centroid = lsoa_data['sheff_lsoa_shape'].centroid
    nodesx = centroid.x.tolist()
    nodesy = centroid.y.tolist()
    nodesx = np.asarray(nodesx)
    nodesy = np.asarray(nodesy)
    east_inds = np.argsort(nodesx)
    
    
    means = paths_shuffle(lsoa_data['sheff_lsoa_shape'], lsoa_data['income_params'])
    means = np.asarray(means)
    
    means_norm = np.divide(np.subtract(means, means.min()),
                                np.subtract(means.max(), means.min())) 
    
    income_inds = np.argsort(means_norm) #sorting means 
    
    
    
    #sense check
    plt.scatter(nodesx[east_inds], means_norm[income_inds])
    
    
    cNorm  = colors.Normalize(vmin=0, vmax=np.max(means_norm))
    scalarMap = cmx.ScalarMappable(norm=cNorm, cmap='gray')
    # colorList = []
    # for i in range(len(income_inds)):
    #    colorList.append(scalarMap.to_rgba(means_norm[i]))
    
    
    
    fig, [base2, base] = plt.subplots(1,2)
    fig.set_size_inches(7,2.5)
    lsoa_data['sheff_lsoa_shape'].plot(color='white', edgecolor='black', ax=base)
    base.scatter(nodesx[east_inds], nodesy[east_inds], c=means_norm[income_inds], s=8., cmap='gray')
    divider = make_axes_locatable(base)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(scalarMap, cax=cax)
    plt.tight_layout()
    lsoa_data['sheff_lsoa_shape'].plot(color='white', edgecolor='black', ax=base2)
    base2.scatter(nodesx, nodesy, c=means_norm, s=8., cmap='gray')
    divider = make_axes_locatable(base2)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(scalarMap, cax=cax)
    #cax.set_ylabel('normalised income')
    base.set_xticks([])
    base.set_yticks([])
    base2.set_xticks([])
    base2.set_yticks([])
    
    plt.tight_layout()
    fig.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\PIN\reports\layouts.png"), dpi=100, format = 'png')




#4) Creating network graphs
def networkgraph(layout, m, ax_in):
    
    centroid = lsoa_data['sheff_lsoa_shape'].centroid
    nodesx = centroid.x.tolist()
    nodesy = centroid.y.tolist()
    nodes = list(zip(nodesx, nodesy))
    

    
    freq_ind = np.nonzero(layout['edge_freqs'][m])
    edge_freqs = layout['edge_freqs'][m][freq_ind]
    wid_ind = np.nonzero(layout['edge_widths'][m])
    edge_widths = layout['edge_widths'][m][wid_ind]
    
    edges = np.nonzero(layout['edge_freqs'][m])
    edges = list(zip(edges[0], edges[1]))
    
    
    edge_widths = np.log10(edge_widths)#taking logarithm prior to norm
    
    edge_freqs = (edge_freqs - edge_freqs.min()) / (edge_freqs.max() - edge_freqs.min()) #normalising freqs
    edge_widths_map = (edge_widths - edge_widths.min()) / (edge_widths.max() - edge_widths.min()) #normalising strength

    nodes2 = list(zip([i for i in range(len(nodes))], nodesx, nodesy))
    def Convert(tup, di): 
        for a, b, c in tup: 
            #di.setdefault(a, []).append((b,c)) 
            di.setdefault(a, (b,c)) 
        return di 
    di={}
    di = Convert(nodes2, di)
    
    # Add a color_map for the edges
    cNorm  = colors.Normalize(vmin=0, vmax=np.max(edge_widths_map))
    scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=plt.cm.Greys)
    colorList = []
    for i in range(len(edges)):
       colorList.append(scalarMap.to_rgba(edge_widths_map[i]))
    
    Ninds = np.argsort(edge_widths)[-int(len(edge_freqs)*0.1):] #strongest 10% edges
    edge_freqs = edge_freqs[Ninds]
    colorList = [colorList[i] for i in Ninds]
    edges = [edges[i] for i in Ninds]
    
    G = nx.house_graph()
    
    for i in range(len(nodes)):
        G.add_node(i, pos = nodes[i])
    for i in range(len(edges)):
        G.add_edge(edges[i][0], edges[i][1])
    
    
    lsoa_data['sheff_lsoa_shape'].plot(color='white', edgecolor='black', ax=ax_in)
    # nx.drawing.nx_pylab.draw_networkx(G, di, node_colour='b', node_size=5, width=edge_freqs*100, edge_color=colorList,  with_labels=False, ax=base)
    #nodes_dr = nx.draw_networkx_nodes(G, di, node_colour = 'k', node_size=4, with_labels=False, ax = ax_in)
    edges_dr = nx.draw_networkx_edges(G, di, width=edge_freqs, edge_color=colorList, alpha = 0.5, ax=ax_in)
    #plt.colorbar(scalarMap, ax=ax_in)
    divider = make_axes_locatable(ax_in)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cax.set_ylabel('edge strength')
    plt.colorbar(scalarMap, cax=cax)





#Loading data ----------------------------------------------------------------
lsoa_data = load_obj("lsoa_data")
normal = load_obj("normal_layout_100run")
minmax = load_obj("minmax_layout_100run")
slmin = load_obj("slmin_layout_100run")
od50 = load_obj("od50_layout_100run")
#-----------------------------------------------------------------------------


#Plot m sensitivity network---------------------------------------------------
# fig, ax0 = plt.subplots(1,1)
# fig.set_size_inches(6,3.5)
# networkgraph(normal, 0, ax0)
# plt.tight_layout()
# fig, ax0 = plt.subplots(1,1)
# fig.set_size_inches(6,3.5)
# networkgraph(normal, 1, ax0)
# plt.tight_layout()
# fig, ax0 = plt.subplots(1,1)
# fig.set_size_inches(6,3.5)
# networkgraph(normal, 2, ax0)
# plt.tight_layout()
#fig.savefig(os.path.join(os.environ['USERPROFILE'] + r"\Dropbox\PIN\reports\network_show.png"), dpi=100, format = 'png')
#-----------------------------------------------------------------------------


#Density ratios and productivity plot ----------------------------------------
#Create density ratios
normal['ratios'], minmax['ratios'], slmin['ratios'], od50['ratios'] = [], [], [], []
base = np.asarray(normal['UrbanYs'][1])
for i in range(len(normal['m_values'])):
    normal['ratios'].append(density_ratio(np.asarray(normal['UrbanYs'][i]), base))
    minmax['ratios'].append(density_ratio(np.asarray(minmax['UrbanYs'][i]), base))
    slmin['ratios'].append(density_ratio(np.asarray(slmin['UrbanYs'][i]), base))
    od50['ratios'].append(density_ratio(np.asarray(od50['UrbanYs'][i]), base))
    
dfs = []
for i in range(len(normal['m_values'])):
    dfs.append(pd.DataFrame(data = {'Normal':normal['ratios'][i]['sorted_ratios'], 
                                    'Minmax':minmax['ratios'][i]['sorted_ratios'],
                                    'slmin':slmin['ratios'][i]['sorted_ratios'],
                                    'od50':od50['ratios'][i]['sorted_ratios']}))    

fig, [ax0, ax1, ax2] = plt.subplots(3,1)
fig.set_size_inches(6,8)
ax0.set_title('m = 0.5')
ax1.set_title('m = 1')
ax2.set_title('m = 2')
sns.boxplot(data = dfs[0], notch=True, showfliers=False, showmeans=True, palette = 'Blues', ax=ax0)
sns.boxplot(data = dfs[1], notch=True, showfliers=False, showmeans=True, palette = 'Blues', ax=ax1)
sns.boxplot(data = dfs[2], notch=True, showfliers=False, showmeans=True, palette = 'Blues', ax=ax2)
# sns.pointplot(data = dfs[0], ci = 'sd', orient = 'v', join = False, ax= ax0)
# sns.pointplot(data = dfs[1], ci = 'sd', orient = 'v', join = False, ax= ax1)
# sns.pointplot(data = dfs[2], ci = 'sd', orient = 'v', join = False, ax= ax2)
ax0.axhline(y=dfs[0]['Normal'].median(), ls='--', lw=1.5)
ax1.axhline(y=dfs[1]['Normal'].median(), ls='--', lw=1.5)
ax2.axhline(y=dfs[2]['Normal'].median(), ls='--', lw=1.5)
ax0.axhline(y=dfs[0]['Normal'].mean(), ls='--', lw=1)
ax1.axhline(y=dfs[1]['Normal'].mean(), ls='--', lw=1)
ax2.axhline(y=dfs[2]['Normal'].mean(), ls='--', lw=1)
plt.tight_layout()


names = ['Normal', 'Minmax', 'slmin', 'od50']
meds05 = [normal['ratios'][0]['median'], minmax['ratios'][0]['median'], slmin['ratios'][0]['median'], od50['ratios'][0]['median']]
meds1  = [normal['ratios'][1]['median'], minmax['ratios'][1]['median'], slmin['ratios'][1]['median'], od50['ratios'][1]['median']]
meds2  = [normal['ratios'][2]['median'], minmax['ratios'][2]['median'], slmin['ratios'][2]['median'], od50['ratios'][2]['median']]
means05 = [normal['ratios'][0]['mean'], minmax['ratios'][0]['mean'], slmin['ratios'][0]['mean'], od50['ratios'][0]['mean']]
means1  = [normal['ratios'][1]['mean'], minmax['ratios'][1]['mean'], slmin['ratios'][1]['mean'], od50['ratios'][1]['mean']]
means2  = [normal['ratios'][2]['mean'], minmax['ratios'][2]['mean'], slmin['ratios'][2]['mean'], od50['ratios'][2]['mean']]

#-----------------------------------------------------------------------------

#heatmap of lsoas ------------------------------------------------------------

#-----------------------------------------------------------------------------